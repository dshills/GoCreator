package models

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"time"
)

// OutputStatus represents the status of generation output
type OutputStatus string

// OutputStatus constants define the possible states of generation output
const (
	OutputStatusPending    OutputStatus = "pending"
	OutputStatusInProgress OutputStatus = "in_progress"
	OutputStatusCompleted  OutputStatus = "completed"
	OutputStatusFailed     OutputStatus = "failed"
)

// GeneratedFile represents a file generated by the system
type GeneratedFile struct {
	Path        string    `json:"path"`
	Content     string    `json:"content"`
	Checksum    string    `json:"checksum"`
	GeneratedAt time.Time `json:"generated_at,omitempty"`
	Generator   string    `json:"generator,omitempty"`
}

// VerifyChecksum verifies the checksum of the generated file
func (g *GeneratedFile) VerifyChecksum() bool {
	if g.Checksum == "" {
		return false
	}

	hash := sha256.Sum256([]byte(g.Content))
	expectedChecksum := hex.EncodeToString(hash[:])

	return g.Checksum == expectedChecksum
}

// Patch represents a patch to an existing file
type Patch struct {
	TargetFile string    `json:"target_file"`
	Diff       string    `json:"diff"`
	AppliedAt  time.Time `json:"applied_at,omitempty"`
	Reversible bool      `json:"reversible"`
}

// OutputMetadata contains metadata about the generation output
type OutputMetadata struct {
	StartedAt   time.Time     `json:"started_at"`
	CompletedAt *time.Time    `json:"completed_at,omitempty"`
	Duration    time.Duration `json:"duration,omitempty"`
	FilesCount  int           `json:"files_count"`
	LinesCount  int           `json:"lines_count"`
}

// GenerationOutput represents the output of the generation process
type GenerationOutput struct {
	SchemaVersion string          `json:"schema_version"`
	ID            string          `json:"id"`
	PlanID        string          `json:"plan_id"`
	Files         []GeneratedFile `json:"files"`
	Patches       []Patch         `json:"patches,omitempty"`
	Metadata      OutputMetadata  `json:"metadata"`
	Status        OutputStatus    `json:"status"`
}

// Validate validates the generation output
func (g *GenerationOutput) Validate() error {
	// Check for duplicate file paths first
	seen := make(map[string]bool)
	for _, file := range g.Files {
		if seen[file.Path] {
			return fmt.Errorf("duplicate file path: %s", file.Path)
		}
		seen[file.Path] = true
	}

	// Then verify checksums
	for _, file := range g.Files {
		if !file.VerifyChecksum() {
			return fmt.Errorf("checksum mismatch for file: %s", file.Path)
		}
	}

	return nil
}

// TransitionTo attempts to transition the output to a new status
func (g *GenerationOutput) TransitionTo(newStatus OutputStatus) error {
	// Define valid status transitions
	validTransitions := map[OutputStatus][]OutputStatus{
		OutputStatusPending:    {OutputStatusInProgress},
		OutputStatusInProgress: {OutputStatusCompleted, OutputStatusFailed},
		OutputStatusCompleted:  {}, // Terminal state
		OutputStatusFailed:     {}, // Terminal state
	}

	allowed, ok := validTransitions[g.Status]
	if !ok {
		return fmt.Errorf("unknown status: %s", g.Status)
	}

	// Check if transition is allowed
	for _, allowedStatus := range allowed {
		if allowedStatus == newStatus {
			g.Status = newStatus
			return nil
		}
	}

	return fmt.Errorf("invalid status transition from %s to %s", g.Status, newStatus)
}
